/* autogenerated by Processing revision 1295 on 2025-12-25 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.ArrayList;
import java.util.ArrayList;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class scopture extends PApplet {



// Layout Constants
int uiWidth = 300;
int previewWidth = 1200;
int previewHeight = 800;

ArrayList<ProjectionWindow> windows;
OutputFrame outputWindow;
ConfigManager configManager;

// UI Elements
ArrayList<Button> buttons = new ArrayList<Button>();
ArrayList<Slider> sliders = new ArrayList<Slider>();

// UI State
boolean applyToAll = false;
boolean editStroke = false;

// Animation State
float globalTime = 0;
float animSpeed = 0.02f;     
float animIntensity = 0.0f;  
int animMode = 0;           
boolean autoTimedEvents = false;
boolean syncDynamics = false;

// Event Toggles
boolean allowModeSwitch = true;
boolean allowShapeSwitch = true;
boolean allowColorSwitch = true;

// BPM & Event State
float bpm = 120;
int lastBeatTime = 0;
int totalBeats = 0;

// Event Logic
int eventInterval = 1; // Fire every 1 beat by default

int nextModeSwitch = 1;
int modeBeatCounter = 0;

int nextShapeSwitch = 1;
int shapeBeatCounter = 0;

int nextColorSwitch = 1;
int colorBeatCounter = 0;

public void settings() {
  size(uiWidth + previewWidth, previewHeight); // 1500 x 800
}

public void setup() {
  surface.setTitle("Scopture Control & Preview");
  windows = new ArrayList<ProjectionWindow>();
  configManager = new ConfigManager(this);
  
  setupUI();
  
  addWindow();
}

public void setupUI() {
  int y = 20;
  int x = 20;
  int spacing = 30;
  
  // --- File & Window Mgmt ---
  buttons.add(new Button("Add Window", x, y, 100, 20, () -> addWindow()));
  buttons.add(new Button("Remove Sel", x + 110, y, 100, 20, () -> removeSelected()));
  y += spacing;
  
  buttons.add(new Button("Save JSON", x, y, 100, 20, () -> configManager.saveSettings(windows, "layout.json")));
  buttons.add(new Button("Load JSON", x + 110, y, 100, 20, () -> configManager.loadSettings(windows, "layout.json")));
  y += spacing;
  
  // --- Output Window ---
  buttons.add(new Button("Open Output", x, y, 210, 20, () -> openOutputWindow()));
  y += spacing + 10;
  
  // --- Targeting ---
  buttons.add(new Toggle("Target: Selected", "Target: All", x, y, 210, 20, (val) -> applyToAll = val));
  y += spacing + 10;
  
  // --- Base Properties ---
  String[] shapes = {"Dot", "Line", "Tri", "Sqr", "Hex", "Circ"};
  for (int i = 0; i < shapes.length; i++) {
    final int shapeType = i;
    buttons.add(new Button(shapes[i], x + (i * 35), y, 30, 20, () -> applyShape(shapeType)));
  }
  y += spacing;
  
  sliders.add(new Slider("Size", 10, 300, 100, x, y, 210, 20, (val) -> applySize(val)));
  y += spacing;
  sliders.add(new Slider("Rotation", 0, TWO_PI, 0, x, y, 210, 20, (val) -> applyRotation(val)));
  y += spacing;
  sliders.add(new Slider("Stroke W", 0, 20, 2, x, y, 210, 20, (val) -> applyStrokeWeight(val)));
  y += spacing;
  
  // Color
  y += 10;
  buttons.add(new Toggle("Edit: Fill", "Edit: Stroke", x, y, 210, 20, (val) -> editStroke = val));
  y += spacing;
  
  sliders.add(new Slider("Red", 0, 255, 255, x, y, 210, 20, (val) -> applyColor()));
  y += spacing;
  sliders.add(new Slider("Green", 0, 255, 255, x, y, 210, 20, (val) -> applyColor()));
  y += spacing;
  sliders.add(new Slider("Blue", 0, 255, 255, x, y, 210, 20, (val) -> applyColor()));
  y += spacing;
  sliders.add(new Slider("Alpha", 0, 255, 100, x, y, 210, 20, (val) -> applyColor()));
  y += spacing + 10;
  
  buttons.add(new Button("Randomize All", x, y, 210, 20, () -> randomizeAll()));
  y += spacing + 20;
  
  // --- Dynamics ---
  buttons.add(new Button("Static", x, y, 50, 20, () -> animMode = 0));
  buttons.add(new Button("Noise", x + 55, y, 50, 20, () -> animMode = 1));
  buttons.add(new Button("Wave X", x + 110, y, 50, 20, () -> animMode = 2));
  buttons.add(new Button("Wave Y", x + 165, y, 50, 20, () -> animMode = 3));
  y += spacing;
  
  sliders.add(new Slider("Speed", 0, 0.1f, 0.02f, x, y, 210, 20, (val) -> animSpeed = val));
  y += spacing;
  sliders.add(new Slider("Intensity", 0, 2.0f, 0.0f, x, y, 210, 20, (val) -> animIntensity = val));
  y += spacing;
  
  buttons.add(new Toggle("Sync: Independent", "Sync: Uniform", x, y, 210, 20, (val) -> syncDynamics = val));
  y += spacing;
  
  sliders.add(new Slider("BPM", 1, 200, 120, x, y, 210, 20, (val) -> bpm = val));
  y += spacing;
  
  // Event Choices
  buttons.add(new Toggle("Events: Shape [X]", "Events: Shape [O]", x, y, 100, 20, (val) -> allowShapeSwitch = val));
  buttons.add(new Toggle("Events: Mode [X]", "Events: Mode [O]", x + 110, y, 100, 20, (val) -> allowModeSwitch = val));
  y += spacing;
  buttons.add(new Toggle("Events: Color [X]", "Events: Color [O]", x, y, 100, 20, (val) -> allowColorSwitch = val));
  buttons.add(new Button("Manual Trigger", x + 110, y, 100, 20, () -> triggerEvent(3)));
  y += spacing;
    
  buttons.add(new Toggle("Timed Events: OFF", "Timed Events: ON", x, y, 210, 20, (val) -> autoTimedEvents = val));
}

public void draw() {
  background(0);
  
  // 1. Draw UI Panel
  noStroke();
  fill(50);
  rect(0, 0, uiWidth, height);
  
  drawUI();
  
  // 2. Logic Update
  globalTime += animSpeed;
  handleBPM();
  
  synchronized(windows) {
    for (ProjectionWindow w : windows) {
      w.update(globalTime, animMode, animSpeed, animIntensity, syncDynamics);
    }
  }
  
  // 3. Draw Preview
  pushMatrix();
  translate(uiWidth, 0);
  
  // Optional: Clip to preview area to avoid drawing over UI
  // clip(0, 0, previewWidth, previewHeight); 
  // Processing clip() is sometimes buggy with complex shapes/P3D, but simple here.
  // Instead, we just trust the translation.
  
  synchronized(windows) {
    for (ProjectionWindow w : windows) {
      // Pass 'g' (this PApplet's graphics) and 'true' (show decorations)
      w.draw(this.g, true);
    }
  }
  
  popMatrix();
}

public void drawUI() {
  fill(255);
  textAlign(LEFT, BASELINE);
  text("Control Panel", 20, 15);
  text("Dynamics Mode: " + getModeName(animMode), 20, height - 20);
  
  for (Button b : buttons) b.draw();
  for (Slider s : sliders) s.draw();
}

public String getModeName(int m) {
  if (m == 0) return "Static";
  if (m == 1) return "Noise";
  if (m == 2) return "Wave X";
  if (m == 3) return "Wave Y";
  return "";
}

public void openOutputWindow() {
  // Only open if not exists (simplification)
  // Real robustness might check if window is closed, etc.
  if (outputWindow == null) {
    outputWindow = new OutputFrame(previewWidth, previewHeight, windows);
    String[] args = {"OutputFrame"};
    PApplet.runSketch(args, outputWindow);
  }
}

// --- Interaction Logic ---

public void mousePressed() {
  if (mouseX < uiWidth) {
    // UI Interaction
    for (Button b : buttons) b.mousePressed(mouseX, mouseY);
    for (Slider s : sliders) s.mousePressed(mouseX, mouseY);
  } else {
    // Preview Interaction
    float px = mouseX - uiWidth;
    float py = mouseY;
    
    boolean clickedBackground = true;
    synchronized(windows) {
      for (int i = windows.size() - 1; i >= 0; i--) {
        ProjectionWindow w = windows.get(i);
        w.mousePressed(px, py);
        if (w.isSelected) {
          clickedBackground = false;
          break; 
        }
      }
      
      if (clickedBackground) {
        for (ProjectionWindow w : windows) w.isSelected = false;
      }
    }
  }
}

public void mouseDragged() {
  if (mouseX < uiWidth) {
    for (Slider s : sliders) s.mouseDragged(mouseX, mouseY);
  } else {
    float px = mouseX - uiWidth;
    float py = mouseY;
    synchronized(windows) {
      for (ProjectionWindow w : windows) {
        w.mouseDragged(px, py);
      }
    }
  }
}

public void mouseReleased() {
  synchronized(windows) {
    for (ProjectionWindow w : windows) {
      w.mouseReleased();
    }
  }
}

public void keyPressed() {
  if (key == 's') {
    configManager.saveSettings(windows, "layout.json");
  }
  if (key == 'l') {
    configManager.loadSettings(windows, "layout.json");
  }
}

// --- Application Logic Helpers ---

public void handleBPM() {
  int beatInterval = PApplet.parseInt(60000.0f / bpm); 
  if (millis() - lastBeatTime >= beatInterval) {
    lastBeatTime = millis();
    totalBeats++;
    if (autoTimedEvents) {
      onBeat();
    }
  }
}

public void onBeat() {
  modeBeatCounter++;
  shapeBeatCounter++;
  colorBeatCounter++;
  
  if (allowModeSwitch && modeBeatCounter >= eventInterval) {
    triggerEvent(1); 
    modeBeatCounter = 0;
  }
  
  if (allowShapeSwitch && shapeBeatCounter >= eventInterval) {
    triggerEvent(0); 
    shapeBeatCounter = 0;
  }
  
  if (allowColorSwitch && colorBeatCounter >= eventInterval) {
    triggerEvent(2); 
    colorBeatCounter = 0;
  }
}

public void triggerEvent(int type) {
  if (type == 3) type = PApplet.parseInt(random(3));
  
  if (type == 0) {
    int sType = PApplet.parseInt(random(6));
    synchronized(windows) {
      for (ProjectionWindow w : windows) w.setShapeType(sType);
    }
  } else if (type == 1) {
    animMode = PApplet.parseInt(random(4));
  } else if (type == 2) {
    int c = color(random(255), random(255), random(255), 150);
    float size = random(50, 150);
    float rot = random(TWO_PI);
    synchronized(windows) {
      for (ProjectionWindow w : windows) {
        w.setFillColor(c);
        w.setShapeSize(size);
        w.setRotation(rot);
      }
    }
  }
}

public void addWindow() {
  synchronized(windows) {
    int id = windows.size();
    float defaultRadius = 100;
    // Center relative to Preview Area
    PVector pos = calculateOnionPosition(id, defaultRadius * 2.1f);
    float cx = previewWidth / 2;
    float cy = previewHeight / 2;
    windows.add(new ProjectionWindow(id, cx + pos.x, cy + pos.y, defaultRadius));
  }
}

public PVector calculateOnionPosition(int index, float spacing) {
  if (index == 0) return new PVector(0, 0);
  
  int ring = 1;
  int count = 1; 
  
  while (index >= count + ring * 6) {
    count += ring * 6;
    ring++;
  }
  
  int ringIndex = index - count;
  int itemsInRing = ring * 6;
  
  float angleStep = TWO_PI / itemsInRing;
  float angle = ringIndex * angleStep;
  
  float radius = ring * spacing;
  
  return new PVector(cos(angle) * radius, sin(angle) * radius);
}

public void removeSelected() {
  synchronized(windows) {
    for (int i = windows.size() - 1; i >= 0; i--) {
      if (windows.get(i).isSelected) {
        windows.remove(i);
      }
    }
  }
}

public void applyShape(int type) {
  synchronized(windows) {
    for (ProjectionWindow w : windows) {
      if (applyToAll || w.isSelected) w.setShapeType(type);
    }
  }
}

public void applySize(float val) {
  synchronized(windows) {
    for (ProjectionWindow w : windows) {
      if (applyToAll || w.isSelected) w.setShapeSize(val);
    }
  }
}

public void applyRotation(float val) {
  synchronized(windows) {
    for (ProjectionWindow w : windows) {
      if (applyToAll || w.isSelected) w.setRotation(val);
    }
  }
}

public void applyStrokeWeight(float val) {
  synchronized(windows) {
    for (ProjectionWindow w : windows) {
      if (applyToAll || w.isSelected) w.setStrokeWeight(val);
    }
  }
}

public void applyColor() {
  // Access sliders by index. Ensure order matches setupUI!
  // Sliders: 0=Size, 1=Rot, 2=StrW, 3=R, 4=G, 5=B, 6=A
  // NOTE: This is fragile if setupUI changes order.
  // Better to look them up or store references.
  // For now, based on setupUI:
  // sliders[0] = Size
  // sliders[1] = Rotation
  // sliders[2] = Stroke W
  // sliders[3] = Red
  // sliders[4] = Green
  // sliders[5] = Blue
  // sliders[6] = Alpha
  
  float r = sliders.get(3).value;
  float g = sliders.get(4).value;
  float b = sliders.get(5).value;
  float a = sliders.get(6).value;
  int c = color(r, g, b, a);
  
  synchronized(windows) {
    for (ProjectionWindow w : windows) {
      if (applyToAll || w.isSelected) {
        if (editStroke) {
          w.setStrokeColor(c);
        } else {
          w.setFillColor(c);
        }
      }
    }
  }
}

public void randomizeAll() {
  synchronized(windows) {
    for (ProjectionWindow w : windows) {
       w.setShapeType(PApplet.parseInt(random(6)));
       w.setShapeSize(random(20, 200));
       w.setRotation(random(TWO_PI));
       w.setFillColor(color(random(255), random(255), random(255), random(100, 200)));
    }
  }
}
class ConfigManager {
  PApplet parent;
  
  ConfigManager(PApplet p) {
    this.parent = p;
  }
  
  public void saveSettings(ArrayList<ProjectionWindow> windows, String filename) {
    synchronized(windows) {
      JSONArray jsonWindows = new JSONArray();
      
      for (int i = 0; i < windows.size(); i++) {
        ProjectionWindow w = windows.get(i);
        JSONObject obj = new JSONObject();
        obj.setInt("id", w.id);
        obj.setFloat("x", w.tX); // Save Target X
        obj.setFloat("y", w.tY); // Save Target Y
        obj.setFloat("radius", w.tRadius); // Save Target Radius
        
        JSONObject shapeObj = new JSONObject();
        shapeObj.setInt("type", w.shape.currentShapeType);
        shapeObj.setFloat("size", w.tShapeSize); // Save Target Size
        shapeObj.setFloat("rotation", w.tRotation); // Save Target Rotation
        shapeObj.setInt("strokeColor", w.tStrokeColor); // Save Target Stroke
        shapeObj.setInt("fillColor", w.tFillColor); // Save Target Fill
        shapeObj.setFloat("strokeWeight", w.tStrokeWeight);
        
        obj.setJSONObject("shape", shapeObj);
        jsonWindows.setJSONObject(i, obj);
      }
      
      parent.saveJSONArray(jsonWindows, filename);
      PApplet.println("Saved settings to " + filename);
    }
  }
  
  public void loadSettings(ArrayList<ProjectionWindow> windows, String filename) {
    synchronized(windows) {
      try {
        JSONArray jsonWindows = parent.loadJSONArray(filename);
        if (jsonWindows == null) {
           PApplet.println("File not found or empty: " + filename);
           return;
        }
        windows.clear();
        
        for (int i = 0; i < jsonWindows.size(); i++) {
          JSONObject obj = jsonWindows.getJSONObject(i);
          int id = obj.getInt("id");
          float x = obj.getFloat("x");
          float y = obj.getFloat("y");
          float r = obj.getFloat("radius");
          
          ProjectionWindow w = new ProjectionWindow(id, x, y, r);
          
          if (obj.hasKey("shape")) {
            JSONObject shapeObj = obj.getJSONObject("shape");
            w.setShapeType(shapeObj.getInt("type"));
            w.setShapeSize(shapeObj.getFloat("size"));
            w.setRotation(shapeObj.getFloat("rotation"));
            w.setStrokeColor(shapeObj.getInt("strokeColor"));
            w.setFillColor(shapeObj.getInt("fillColor"));
            w.setStrokeWeight(shapeObj.getFloat("strokeWeight"));
            
            // Force update of currents to match loaded targets immediately?
            // Or let them lerp?
            // Usually load -> snap.
            w.cX = w.tX; w.cY = w.tY;
            w.cRadius = w.tRadius;
            w.cShapeSize = w.tShapeSize;
            w.cRotation = w.tRotation;
            w.cFillColor = w.tFillColor;
            w.cStrokeColor = w.tStrokeColor;
            w.cStrokeWeight = w.tStrokeWeight;
            
            // Update shape immediately
            w.shape.calculateTargetVertices(w.shape.currentShapeType);
            for(int k=0; k<w.shape.vertexCount; k++) {
               w.shape.vertices.set(k, w.shape.targetVertices.get(k).copy());
            }
          }
          
          windows.add(w);
        }
        PApplet.println("Loaded settings from " + filename);
      } catch (Exception e) {
        PApplet.println("Could not load settings: " + e.getMessage());
      }
    }
  }
}
class MorphShape {
  // Shape types
  static final int SHAPE_DOT = 0;
  static final int SHAPE_LINE = 1;
  static final int SHAPE_TRIANGLE = 2;
  static final int SHAPE_SQUARE = 3;
  static final int SHAPE_HEXAGON = 4;
  static final int SHAPE_CIRCLE = 5;

  ArrayList<PVector> vertices = new ArrayList<PVector>();
  ArrayList<PVector> targetVertices = new ArrayList<PVector>();
  
  // Configuration
  int vertexCount = 120; 
  float currentSize = 100;
  int currentShapeType = SHAPE_CIRCLE;
  
  // Visual properties
  int strokeColor = color(255);
  int fillColor = color(255, 100);
  float strokeWeightVal = 2;
  float rotation = 0;
  
  MorphShape(float size) {
    this.currentSize = size;
    initVertices();
    setTargetShape(SHAPE_CIRCLE);
    for (int i = 0; i < vertexCount; i++) {
      vertices.set(i, targetVertices.get(i).copy());
    }
  }

  public void initVertices() {
    for (int i = 0; i < vertexCount; i++) {
      vertices.add(new PVector());
      targetVertices.add(new PVector());
    }
  }

  public void update() {
    for (int i = 0; i < vertexCount; i++) {
      PVector v = vertices.get(i);
      PVector t = targetVertices.get(i);
      v.x = lerp(v.x, t.x, 0.1f);
      v.y = lerp(v.y, t.y, 0.1f);
    }
  }

  public void update(float time, float intensity) {
    update();
  }

  // Draw to the main screen
  public void draw() {
    draw(null);
  }

  // Draw to a specific PGraphics buffer
  public void draw(PGraphics pg) {
    if (pg != null) {
      pg.pushStyle();
      pg.stroke(strokeColor);
      pg.strokeWeight(strokeWeightVal);
      pg.strokeJoin(ROUND);
      pg.strokeCap(ROUND);
      pg.fill(fillColor);
      pg.pushMatrix();
      pg.rotate(rotation);
      pg.beginShape();
      for (PVector v : vertices) pg.vertex(v.x, v.y);
      pg.endShape(CLOSE);
      pg.popMatrix();
      pg.popStyle();
    } else {
      pushStyle();
      stroke(strokeColor);
      strokeWeight(strokeWeightVal);
      strokeJoin(ROUND);
      strokeCap(ROUND);
      fill(fillColor);
      pushMatrix();
      rotate(rotation);
      beginShape();
      for (PVector v : vertices) vertex(v.x, v.y);
      endShape(CLOSE);
      popMatrix();
      popStyle();
    }
  }

  public void setTargetShape(int type) {
    this.currentShapeType = type;
    calculateTargetVertices(type);
  }

  public void calculateTargetVertices(int type) {
    float r = currentSize / 2;
    for (int i = 0; i < vertexCount; i++) {
      float progress = (float)i / vertexCount;
      float angle = map(progress, 0, 1, 0, TWO_PI);
      float x = 0, y = 0;
      switch (type) {
        case SHAPE_DOT: x = cos(angle) * 1.5f; y = sin(angle) * 1.5f; break;
        case SHAPE_LINE: 
          if (progress < 0.5f) { x = map(progress, 0, 0.5f, -r, r); y = -2; }
          else { x = map(progress, 0.5f, 1.0f, r, -r); y = 2; }
          break;
        case SHAPE_TRIANGLE:
          // Triangle Corners
          float cx1 = r * cos(PI/6); float cy1 = r * sin(PI/6); // BotRight
          float cx2 = r * cos(5*PI/6); float cy2 = r * sin(5*PI/6); // BotLeft
          float cx3 = 0; float cy3 = -r; // Top
          
          // Start at Midpoint of Right Side (Top to BotRight)
          float sx = lerp(cx3, cx1, 0.5f);
          float sy = lerp(cy3, cy1, 0.5f);
          
          if (progress < 1.0f/6.0f) { 
             // Leg 1: Mid-Right to BotRight
             float p = map(progress, 0, 1.0f/6.0f, 0, 1);
             x = lerp(sx, cx1, p);
             y = lerp(sy, cy1, p);
          } else if (progress < 3.0f/6.0f) { // Up to 1/2
             // Leg 2: BotRight to BotLeft
             float p = map(progress, 1.0f/6.0f, 3.0f/6.0f, 0, 1);
             x = lerp(cx1, cx2, p);
             y = lerp(cy1, cy2, p);
          } else if (progress < 5.0f/6.0f) { // Up to 5/6
             // Leg 3: BotLeft to Top
             float p = map(progress, 3.0f/6.0f, 5.0f/6.0f, 0, 1);
             x = lerp(cx2, cx3, p);
             y = lerp(cy2, cy3, p);
          } else {
             // Leg 4: Top to Mid-Right
             float p = map(progress, 5.0f/6.0f, 1.0f, 0, 1);
             x = lerp(cx3, sx, p);
             y = lerp(cy3, sy, p);
          }
          break;
        case SHAPE_SQUARE:
           if (progress < 0.25f) { x = map(progress, 0, 0.25f, -r, r); y = -r; }
           else if (progress < 0.5f) { x = r; y = map(progress, 0.25f, 0.5f, -r, r); }
           else if (progress < 0.75f) { x = map(progress, 0.5f, 0.75f, r, -r); y = r; }
           else { x = -r; y = map(progress, 0.75f, 1.0f, r, -r); }
           break;
        case SHAPE_HEXAGON:
           int side = floor(progress * 6);
           float p = (progress * 6) - side;
           float a1 = map(side, 0, 6, -PI/2, TWO_PI - PI/2);
           float a2 = map(side+1, 0, 6, -PI/2, TWO_PI - PI/2);
           x = lerp(r * cos(a1), r * cos(a2), p);
           y = lerp(r * sin(a1), r * sin(a2), p);
           break;
        case SHAPE_CIRCLE: x = cos(angle - PI/2) * r; y = sin(angle - PI/2) * r; break;
      }
      targetVertices.get(i).set(x, y);
    }
  }
}


public class OutputFrame extends PApplet {
  int w, h;
  ArrayList<ProjectionWindow> windows;
  
  // Animation State References (local copies or access to parent? 
  // It's better if the parent passes updated windows, but windows store their own state.
  // The 'update' is called in main loop. Here we just draw.
  
  public OutputFrame(int _w, int _h, ArrayList<ProjectionWindow> _windows) {
    w = _w;
    h = _h;
    windows = _windows;
  }
  
  public void settings() {
    size(w, h); // Standard projector resolution usually
  }
  
  public void setup() {
    surface.setTitle("Output Projection");
  }
  
  public void draw() {
    background(0);
    
    // We assume 'windows' are updated in the main sketch.
    // We just draw them here.
    
    synchronized(windows) {
      for (ProjectionWindow w : windows) {
        // Draw WITHOUT decorations
        w.draw(this.g, false);
      }
    }
  }
}
class ProjectionWindow {
  // Target Base Properties (Where we want to be)
  float tX, tY;
  float tRadius;
  float tShapeSize;
  float tRotation = 0;
  int tFillColor = color(255, 100);
  int tStrokeColor = color(255);
  float tStrokeWeight = 2;
  
  // Current Properties (Where we are)
  float cX, cY;
  float cRadius;
  float cShapeSize;
  float cRotation = 0;
  int cFillColor = color(255, 100);
  int cStrokeColor = color(255);
  float cStrokeWeight = 2;
  
  // Interaction
  boolean isDragging = false;
  boolean isResizing = false;
  boolean isSelected = false;
  float dragOffsetX, dragOffsetY;
  
  MorphShape shape;
  int id;
  float seed;
  
  // Lerp Speed
  float lerpSpeed = 0.05f;
  
  // Animation Modulators
  float animOffsetX, animOffsetY;
  
  // Masking Buffers
  PGraphics pg;
  PGraphics pgMask;
  
  ProjectionWindow(int id, float x, float y, float radius) {
    this.id = id;
    this.tX = x; this.tY = y;
    this.tRadius = radius;
    this.tShapeSize = radius * 1.5f; 
    
    // Init currents
    this.cX = x; this.cY = y;
    this.cRadius = radius;
    this.cShapeSize = tShapeSize;
    
    this.shape = new MorphShape(cShapeSize);
    this.seed = random(1000);
    
    // Init colors
    shape.fillColor = cFillColor;
    shape.strokeColor = cStrokeColor;
    shape.strokeWeightVal = cStrokeWeight;
    
    checkBuffers();
  }
  
  public void checkBuffers() {
    // Determine required size (diameter + padding)
    int requiredSize = (int)(cRadius * 2 + 20);
    if (pg == null || pg.width != requiredSize) {
      pg = createGraphics(requiredSize, requiredSize);
      pgMask = createGraphics(requiredSize, requiredSize);
      
      // Update mask
      pgMask.beginDraw();
      pgMask.background(0);
      pgMask.fill(255);
      pgMask.noStroke();
      pgMask.ellipse(requiredSize/2, requiredSize/2, cRadius * 2, cRadius * 2);
      pgMask.endDraw();
    }
  }

  public void update(float time, int mode, float speed, float intensity, boolean sync) {
    // 1. LERP Base Properties towards Targets
    cX = lerp(cX, tX, lerpSpeed);
    cY = lerp(cY, tY, lerpSpeed);
    cRadius = lerp(cRadius, tRadius, lerpSpeed);
    cShapeSize = lerp(cShapeSize, tShapeSize, lerpSpeed);
    cRotation = lerp(cRotation, tRotation, lerpSpeed);
    cStrokeWeight = lerp(cStrokeWeight, tStrokeWeight, lerpSpeed);
    
    cFillColor = lerpColor(cFillColor, tFillColor, lerpSpeed);
    cStrokeColor = lerpColor(cStrokeColor, tStrokeColor, lerpSpeed);
    
    checkBuffers();
    
    // 2. Calculate Animation/Noise
    float effectiveSeed = sync ? 0 : seed;
    float mod = 0;
    float colorMod = 0;
    float posXMod = 0;
    float posYMod = 0;
    
    switch (mode) {
      case 0: break;
      case 1: 
        mod = noise(effectiveSeed + time * speed) - 0.5f;
        colorMod = noise(effectiveSeed + 500 + time * speed) - 0.5f;
        posXMod = noise(effectiveSeed + 1000 + time * speed) - 0.5f;
        posYMod = noise(effectiveSeed + 2000 + time * speed) - 0.5f;
        break;
      case 2:
        float phaseX = map(cX, 0, width, 0, TWO_PI);
        float waveVal = sin(phaseX + time * speed * 5);
        mod = waveVal * 0.5f;
        colorMod = cos(phaseX + time * speed * 5) * 0.5f;
        posYMod = waveVal * 0.5f;
        break;
      case 3:
        float phaseY = map(cY, 0, height, 0, TWO_PI);
        float waveValY = sin(phaseY + time * speed * 5);
        mod = waveValY * 0.5f;
        colorMod = cos(phaseY + time * speed * 5) * 0.5f;
        posXMod = waveValY * 0.5f;
        break;
    }
    
    // 3. Apply Animation to produce Final Drawing Values
    // Position Offsets (Shape can now freely move, it will be masked)
    animOffsetX = posXMod * cRadius * intensity * 2.0f;
    animOffsetY = posYMod * cRadius * intensity * 2.0f;
    
    // Size Modulation
    float sizeVar = 1.0f + (mod * intensity * 2.0f);
    shape.currentSize = cShapeSize * sizeVar;
    shape.calculateTargetVertices(shape.currentShapeType);
    
    // Rotation
    shape.rotation = cRotation + (mod * TWO_PI * intensity);
    
    // Color
    float alphaVar = 1.0f + (colorMod * intensity);
    float a = alpha(cFillColor) * constrain(alphaVar, 0.2f, 1.0f);
    shape.fillColor = color(red(cFillColor), green(cFillColor), blue(cFillColor), a);
    shape.strokeColor = cStrokeColor;
    shape.strokeWeightVal = cStrokeWeight;
    
    shape.update();
  }
  
  public void update() { shape.update(); }
  
  public void draw() {
    draw(null, true);
  }

  public void draw(PGraphics context, boolean drawDecorations) {
    // Determine target PGraphics or PApplet
    // Since 'g' is PGraphics, we can use that interface. 
    // If context is null, use the current PApplet's main graphics (g).
    // However, in Processing code, 'g' is available globally within classes usually?
    // No, 'g' belongs to the PApplet. If this class is not an inner class of PApplet, 
    // it technically doesn't see 'g' unless passed or if it uses PApplet functions which delegate to static/global context?
    // Actually, in .pde files, classes are inner classes of the main PApplet by default?
    // - "scopture.pde" compiles to a class. "ProjectionWindow" is usually an inner class.
    // - BUT if it's in a separate tab/file, it's still an inner class of the main sketch class.
    // - HOWEVER, we are drawing from *other* PApplets (OutputFrame). 
    // - 'g' in 'ProjectionWindow' will refer to the MAIN sketch's 'g'.
    // - So we MUST pass the context if we want to draw to a different PApplet.
    
    PGraphics target = (context == null) ? g : context;

    // Draw the shape into the buffer
    pg.beginDraw();
    pg.background(0, 0); // Transparent (0 alpha)
    pg.pushMatrix();
    pg.translate(pg.width/2 + animOffsetX, pg.height/2 + animOffsetY);
    shape.draw(pg);
    pg.popMatrix();
    pg.endDraw();
    
    // Mask it
    pg.mask(pgMask);
    
    target.pushMatrix();
    target.translate(cX, cY);
    
    // Draw the masked shape
    target.imageMode(CENTER);
    target.image(pg, 0, 0);
    
    // Draw Window Boundary (the frame)
    if (drawDecorations) {
      target.noFill();
      if (isSelected) {
        target.stroke(0, 255, 255);
        target.strokeWeight(3);
      } else {
        target.stroke(100);
        target.strokeWeight(1);
      }
      target.ellipse(0, 0, cRadius * 2, cRadius * 2);
    }
    
    target.popMatrix();
  }
  
  public boolean contains(float px, float py) {
    return dist(px, py, cX, cY) < cRadius;
  }
  
  public boolean onEdge(float px, float py) {
    float d = dist(px, py, cX, cY);
    return d > cRadius - 10 && d < cRadius + 10;
  }
  
  public void mousePressed(float px, float py) {
    if (onEdge(px, py)) {
      isResizing = true;
      isSelected = true;
    } else if (contains(px, py)) {
      isDragging = true;
      dragOffsetX = tX - px;
      dragOffsetY = tY - py;
      isSelected = true;
    } else {
      isSelected = false;
    }
  }
  
  public void mouseDragged(float px, float py) {
    if (isResizing) {
      float d = dist(px, py, cX, cY);
      tRadius = max(20, d);
    } else if (isDragging) {
      tX = px + dragOffsetX;
      tY = py + dragOffsetY;
    }
  }
  
  public void mouseReleased() {
    isDragging = false;
    isResizing = false;
  }
  
  public void setShapeType(int type) { shape.setTargetShape(type); }
  public void setShapeSize(float s) { tShapeSize = s; }
  public void setRotation(float r) { tRotation = r; }
  public void setStrokeColor(int c) { tStrokeColor = c; }
  public void setFillColor(int c) { tFillColor = c; }
  public void setStrokeWeight(float w) { tStrokeWeight = w; }
}
interface Action { void execute(); }
interface ToggleAction { void execute(boolean val); }
interface SliderAction { void execute(float val); }

class Button {
  String label; float x, y, w, h; Action action;
  Button(String label, float x, float y, float w, float h, Action action) {
    this.label = label; this.x = x; this.y = y; this.w = w; this.h = h; this.action = action;
  }
  public void draw() {
    fill(100); stroke(255);
    rect(x, y, w, h);
    fill(255); textAlign(CENTER, CENTER);
    text(label, x + w/2, y + h/2);
  }
  public void mousePressed(float mx, float my) {
    if (mx > x && mx < x + w && my > y && my < y + h) {
       if (action != null) action.execute();
    }
  }
}

class Toggle extends Button {
  boolean state = false;
  String labelTrue;
  ToggleAction toggleAction;
  Toggle(String labelFalse, String labelTrue, float x, float y, float w, float h, ToggleAction action) {
    super(labelFalse, x, y, w, h, null);
    this.labelTrue = labelTrue;
    this.toggleAction = action;
  }
  public void draw() {
    fill(state ? 0 : 100); stroke(255); if(state) fill(0, 100, 0);
    rect(x, y, w, h);
    fill(255); textAlign(CENTER, CENTER);
    text(state ? labelTrue : label, x + w/2, y + h/2);
  }
  public void mousePressed(float mx, float my) {
    if (mx > x && mx < x + w && my > y && my < y + h) {
      state = !state;
      toggleAction.execute(state);
    }
  }
}

class Slider {
  String label; float min, max, value; float x, y, w, h; SliderAction action;
  Slider(String label, float min, float max, float val, float x, float y, float w, float h, SliderAction action) {
    this.label = label; this.min = min; this.max = max; this.value = val;
    this.x = x; this.y = y; this.w = w; this.h = h; this.action = action;
  }
  public void draw() {
    fill(80); noStroke();
    rect(x, y, w, h);
    float pos = map(value, min, max, x, x + w);
    fill(150);
    rect(x, y, pos - x, h);
    fill(255);
    rect(pos - 2, y, 4, h);
    textAlign(LEFT, CENTER);
    fill(255);
    text(label + ": " + nf(value, 0, 1), x + 5, y + h/2);
  }
  public void mousePressed(float mx, float my) {
    if (mx > x && mx < x + w && my > y && my < y + h) {
      value = map(mx, x, x + w, min, max);
      action.execute(value);
    }
  }
  public void mouseDragged(float mx, float my) {
    if (mx > x && mx < x + w && my > y && my < y + h) {
      value = map(mx, x, x + w, min, max);
      action.execute(value);
    }
  }
}


  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "scopture" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}

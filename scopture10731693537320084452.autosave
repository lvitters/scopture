import java.util.ArrayList;

ArrayList<ProjectionWindow> windows;
ControlFrame cf;

// Animation State
float globalTime = 0;
float animSpeed = 0.02;
float animIntensity = 0.0; // 0 = Static by default
int animMode = 0; // 0=Static, 1=Noise, 2=WaveX, 3=WaveY
boolean autoTimedEvents = false;
boolean syncDynamics = false;

// Timed Events State (similar to untiled.js)
float maxSwitchTime = 30; // seconds
float nextModeSwitch = 10;
float modeSwitchCounter = 0;
float nextShapeSwitch = 10;
float shapeSwitchCounter = 0;
float nextColorSwitch = 10;
float colorSwitchCounter = 0;

void settings() {
  size(1200, 800); // Windowed mode for testing
}

void setup() {
  background(0);
  windows = new ArrayList<ProjectionWindow>();
  
  // Create an initial window
  addWindow();
  
  // Launch Control Window
  cf = new ControlFrame(this, 300, 600, windows);
  String[] args = {"ControlFrame"};
  PApplet.runSketch(args, cf);
  
  // Set window title
  surface.setTitle("Scopture Main Projection");
}

void draw() {
  background(0);
  
  // Update Time
  globalTime += animSpeed;
  
  // Timed Events
  if (autoTimedEvents) {
    timedEvents();
  }
  
  // Update and draw all windows
  synchronized(windows) {
    for (ProjectionWindow w : windows) {
      w.update(globalTime, animMode, animSpeed, animIntensity, syncDynamics);
      w.draw();
    }
  }
}

void timedEvents() {
  // Counters increment by 1/60th of a second (assuming 60fps) or just 1 frame
  // untiled.js used frame count logic: > nextSwitch * 60
  
  modeSwitchCounter++;
  shapeSwitchCounter++;
  colorSwitchCounter++;
  
  // Mode Switch
  if (modeSwitchCounter > nextModeSwitch * 60) {
    animMode = int(random(4));
    nextModeSwitch = random(10, maxSwitchTime);
    modeSwitchCounter = 0;
    // println("Mode switched to: " + animMode);
  }
  
  // Shape Switch
  if (shapeSwitchCounter > nextShapeSwitch * 60) {
    int type = int(random(6));
    synchronized(windows) {
      for (ProjectionWindow w : windows) w.setShapeType(type);
    }
    nextShapeSwitch = random(5, maxSwitchTime);
    shapeSwitchCounter = 0;
    // println("Shapes switched to: " + type);
  }
  
  // Color/Attr Switch
  if (colorSwitchCounter > nextColorSwitch * 60) {
    color c = color(random(255), random(255), random(255), 150);
    float size = random(50, 150);
    float rot = random(TWO_PI);
    synchronized(windows) {
      for (ProjectionWindow w : windows) {
        w.setFillColor(c);
        w.setShapeSize(size); // Lerped
        w.setRotation(rot);   // Lerped
      }
    }
    nextColorSwitch = random(5, maxSwitchTime);
    colorSwitchCounter = 0;
    // println("Colors/Attrs switched");
  }
}

void addWindow() {
  // Add a new window in an onion/hexagonal pattern
  synchronized(windows) {
    int id = windows.size();
    float defaultRadius = 100;
    PVector pos = calculateOnionPosition(id, defaultRadius * 2.1); // Spacing slightly larger than diameter
    windows.add(new ProjectionWindow(id, width/2 + pos.x, height/2 + pos.y, defaultRadius));
  }
}

PVector calculateOnionPosition(int index, float spacing) {
  if (index == 0) return new PVector(0, 0);
  
  int ring = 1;
  int count = 1; // Items accounted for (center)
  
  while (index >= count + ring * 6) {
    count += ring * 6;
    ring++;
  }
  
  // Index within the current ring
  int ringIndex = index - count;
  int itemsInRing = ring * 6;
  
  float angleStep = TWO_PI / itemsInRing;
  float angle = ringIndex * angleStep;
  
  float radius = ring * spacing;
  
  return new PVector(cos(angle) * radius, sin(angle) * radius);
}

void removeSelected() {
  synchronized(windows) {
    for (int i = windows.size() - 1; i >= 0; i--) {
      if (windows.get(i).isSelected) {
        windows.remove(i);
      }
    }
  }
}

void mousePressed() {
  boolean clickedBackground = true;
  // Iterate backwards to select top-most
  synchronized(windows) {
    for (int i = windows.size() - 1; i >= 0; i--) {
      ProjectionWindow w = windows.get(i);
      w.mousePressed(mouseX, mouseY);
      if (w.isSelected) {
        clickedBackground = false;
        break; 
      }
    }
    
    if (clickedBackground) {
      // Deselect all
      for (ProjectionWindow w : windows) w.isSelected = false;
    }
  }
}

void mouseDragged() {
  synchronized(windows) {
    for (ProjectionWindow w : windows) {
      w.mouseDragged(mouseX, mouseY);
    }
  }
}

void mouseReleased() {
  synchronized(windows) {
    for (ProjectionWindow w : windows) {
      w.mouseReleased();
    }
  }
}

void keyPressed() {
  if (key == 's') {
    if (cf != null && cf.configManager != null) cf.configManager.saveSettings(windows, "layout.json");
  }
  if (key == 'l') {
    if (cf != null && cf.configManager != null) cf.configManager.loadSettings(windows, "layout.json");
  }
}
